diff --git a/README.md b/README.md
index 6ad3269..327e083 100644
--- a/README.md
+++ b/README.md
@@ -19,7 +19,7 @@
 
 ## Spielanleitung
 
-1.  Öffne die `index.html`-Datei in deinem Webbrowser.
+1.  Öffne die Datei `src/index.html` in deinem Webbrowser.
 2.  Wähle ein Level aus, mit dem du beginnen möchtest.
 3.  Schau auf den Buchstaben oder das Wort, das im Anzeigebereich erscheint.
 4.  Drücke die entsprechende Taste auf deiner Tastatur. Die virtuelle Tastatur auf dem Bildschirm hilft dir dabei, die richtige Taste und den richtigen Finger zu finden.
@@ -27,23 +27,24 @@
 
 ## Installation
 
-Es ist keine Installation erforderlich. Lade einfach die Projektdateien herunter und öffne die `index.html` in einem modernen Webbrowser, um loszulegen.
+Es ist keine Installation erforderlich. Lade einfach die Projektdateien herunter und öffne die `src/index.html` in einem modernen Webbrowser, um loszulegen.
 
 ---
 
 ## Running a Simple Python Webserver for Local Testing
 
-To serve this project locally (for example, to test in your browser), you can use Python's built-in HTTP server. Run the following command in your project directory:
+Um das Projekt lokal zu testen, kannst du einen einfachen HTTP-Server mit Python direkt im `src`-Verzeichnis starten. Führe dazu folgende Befehle aus:
 
 ```bash
+cd src
 python3 -m http.server 8000
 ```
 
-Then open [http://localhost:8000](http://localhost:8000) in your browser.
+Öffne dann [http://localhost:8000/](http://localhost:8000/) in deinem Browser.
 
 ## Audio-Generierung: Konfiguration & Ausführung
 
-Mit dem Skript [`generate-audio.js`](generate-audio.js:1) kannst du automatisch Audiodateien für alle Wörter in den JSON-Daten generieren lassen. Folge diesen Schritten, um die Audio-Generierung korrekt einzurichten und auszuführen:
+Mit dem Skript [`scripts/generate-audio.js`](scripts/generate-audio.js:1) kannst du automatisch Audiodateien für alle Wörter in den JSON-Daten generieren lassen. Folge diesen Schritten, um die Audio-Generierung korrekt einzurichten und auszuführen:
 
 ### 1. Voraussetzungen
 
@@ -52,41 +53,23 @@ Mit dem Skript [`generate-audio.js`](generate-audio.js:1) kannst du automatisch
 
 ### 2. TTS-Anbieter & Stimme konfigurieren
 
-Das Projekt unterstützt verschiedene Text-to-Speech-Anbieter (TTS) für die Audioausgabe. Die Auswahl und Konfiguration erfolgt über Umgebungsvariablen oder eine optionale `config.json`.
+Das Projekt unterstützt verschiedene Text-to-Speech-Anbieter (TTS) für die Audioausgabe.
+**WICHTIG:**
+- **API-Keys** (`XI_API_KEY`, `OPENAI_API_KEY`) gehören ausschließlich in die `.env`-Datei im Projektverzeichnis.
+- **Alle anderen Einstellungen** (`TTS_PROVIDER`, `OPENAI_VOICE`, `ELEVENLABS_VOICE`) werden in der Datei `scripts/generate-audio.config` (JSON-Format) vorgenommen.
 
-#### Anbieter wählen
-
-Setze die Umgebungsvariable `TTS_PROVIDER` auf einen der folgenden Werte:
-
-- `elevenlabs`
-- `openai`
-
-#### Stimme (Voice) wählen
-
-Du kannst die gewünschte Stimme für beide Anbieter konfigurieren:
-
-- **Für OpenAI:** Setze `OPENAI_VOICE` (z.B. `"shimmer"` für Deutsch, `"alloy"` für Englisch).
-- **Für ElevenLabs:** Setze `ELEVENLABS_VOICE` (Voice-ID, z.B. `"NBqeXKdZHweef6y0B67V"`).
-
-Die Variablen können in einer `.env`-Datei **oder** in einer `config.json` gesetzt werden. Werte aus `config.json` überschreiben die `.env`, falls beide vorhanden sind.
-
-##### Beispiel `.env`:
+##### Beispiel `.env` (nur API-Keys):
 
 ```
-TTS_PROVIDER=elevenlabs
 XI_API_KEY=dein-elevenlabs-api-key
 OPENAI_API_KEY=dein-openai-api-key
-OPENAI_VOICE=shimmer
-ELEVENLABS_VOICE=NBqeXKdZHweef6y0B67V
 ```
 
-##### Beispiel `config.json`:
+##### Beispiel `scripts/generate-audio.config` (Konfiguration):
 
 ```json
 {
   "TTS_PROVIDER": "openai",
-  "XI_API_KEY": "dein-elevenlabs-api-key",
-  "OPENAI_API_KEY": "dein-openai-api-key",
   "OPENAI_VOICE": "shimmer",
   "ELEVENLABS_VOICE": "NBqeXKdZHweef6y0B67V"
 }
@@ -95,27 +78,29 @@ ELEVENLABS_VOICE=NBqeXKdZHweef6y0B67V
 > **Hinweis:**
 > - Für **OpenAI**: Stimmen wie `"shimmer"` oder `"onyx"` unterstützen Deutsch. Siehe die [OpenAI TTS-Dokumentation](https://platform.openai.com/docs/guides/text-to-speech/voice-options) für eine vollständige Liste.
 > - Für **ElevenLabs**: Die Voice-ID bestimmt die Stimme und Sprache. Siehe das ElevenLabs-Dashboard für verfügbare Stimmen und deren IDs.
+> - Die Datei `scripts/generate-audio.config` überschreibt die entsprechenden Einstellungen aus der `.env`, falls beide vorhanden sind.
 
-#### Benötigte Umgebungsvariablen
-
-- **ElevenLabs:** `XI_API_KEY`, `ELEVENLABS_VOICE` (optional, sonst Standard)
-- **OpenAI:** `OPENAI_API_KEY`, `OPENAI_VOICE` (optional, sonst Standard)
-- Immer: `TTS_PROVIDER` (entweder `elevenlabs` oder `openai`)
+#### Benötigte Einträge
 
-Stimmen-Variablen sind optional. Wird keine gesetzt, wird eine Standardstimme verwendet.
+- **In `.env`:**
+  - Für ElevenLabs: `XI_API_KEY`
+  - Für OpenAI: `OPENAI_API_KEY`
+- **In `scripts/generate-audio.config`:**
+  - `TTS_PROVIDER` (Pflicht: `"elevenlabs"` oder `"openai"`)
+  - Stimmen-Variablen (`OPENAI_VOICE`, `ELEVENLABS_VOICE`) sind optional. Wird keine gesetzt, wird eine Standardstimme verwendet.
 
 ### 3. Skript ausführen
 
 Führe im Projektverzeichnis folgenden Befehl aus:
 
 ```
-node generate-audio.js
+node scripts/generate-audio.js
 ```
 
 ### 4. Was macht das Skript?
 
-- Liest alle JSON-Dateien im Verzeichnis `data/` aus.
-- Extrahiert alle Wörter und generiert für jedes Wort eine Audiodatei (`.mp3`) im Verzeichnis `audio/`.
+- Liest alle JSON-Dateien im Verzeichnis `src/data/` aus.
+- Extrahiert alle Wörter und generiert für jedes Wort eine Audiodatei (`.mp3`) im Verzeichnis `src/audio/`.
 - Verwendet den gewählten TTS-Anbieter (ElevenLabs oder OpenAI) und die konfigurierte Stimme zur Sprachausgabe.
 - Überspringt Wörter, für die bereits eine Audiodatei existiert.
 
diff --git a/config.json b/config.json
deleted file mode 100644
index 3674f5b..0000000
--- a/config.json
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-    "TTS_PROVIDER": "elevenlabs",
-    "OPENAI_VOICE": "fable",
-    "ELEVENLABS_VOICE": "TEViowKnW2MmpkujLKwI"
-}
diff --git a/elevenlabs.js b/elevenlabs.js
deleted file mode 100644
index 19c90fc..0000000
--- a/elevenlabs.js
+++ /dev/null
@@ -1,55 +0,0 @@
-// elevenlabs.js
-require('dotenv').config();
-const fs = require('fs');
-const path = require('path');
-
-/**
- * Generates audio for the given text using the ElevenLabs API and writes it to the specified output path.
- * @param {string} word - The text to synthesize.
- * @param {string} outputPath - The file path to write the resulting audio (should end with .mp3).
- * @returns {Promise<void>} Resolves when the file is written, rejects on error.
- */
-async function generateAudio(word, outputPath, voiceId) {
-    const XI_API_KEY = process.env.XI_API_KEY;
-    const selectedVoiceId = voiceId || process.env.ELEVENLABS_VOICE || "NBqeXKdZHweef6y0B67V";
-
-    if (!XI_API_KEY) {
-        throw new Error("XI_API_KEY is not defined. Please set it in your environment or .env file.");
-    }
-
-    // Dynamically import node-fetch v3 (ESM-only)
-    const { default: fetch } = await import('node-fetch');
-
-    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${selectedVoiceId}`, {
-        method: 'POST',
-        headers: {
-            'Accept': 'audio/mpeg',
-            'Content-Type': 'application/json',
-            'xi-api-key': XI_API_KEY,
-        },
-        body: JSON.stringify({
-            text: word,
-            model_id: 'eleven_multilingual_v2',
-            voice_settings: { stability: 0.5, similarity_boost: 0.75 },
-            lang: 'de'
-        }),
-    });
-
-    if (!response.ok) {
-        const errText = await response.text().catch(() => '');
-        throw new Error(`ElevenLabs API error: ${response.status} ${response.statusText} - ${errText}`);
-    }
-
-    const arrayBuffer = await response.arrayBuffer();
-    const audioBuffer = Buffer.from(arrayBuffer);
-
-    // Ensure the output directory exists
-    const dir = path.dirname(outputPath);
-    if (!fs.existsSync(dir)) {
-        fs.mkdirSync(dir, { recursive: true });
-    }
-
-    fs.writeFileSync(outputPath, audioBuffer);
-}
-
-module.exports = { generateAudio };
\ No newline at end of file
diff --git a/generate-audio.js b/generate-audio.js
deleted file mode 100644
index 06c84e4..0000000
--- a/generate-audio.js
+++ /dev/null
@@ -1,199 +0,0 @@
-// A Node.js script to pre-generate all audio files from JSON data files.
-
-require('dotenv').config(); // Load environment variables from .env file
-const fs = require('fs');
-const path = require('path');
-
-// --- TTS PROVIDER SELECTION ---
-const elevenlabs = require('./elevenlabs');
-const openai = require('./openai');
-
-/**
- * TTS Provider selection precedence:
- * 1. Use process.env.TTS_PROVIDER if set (from .env).
- * 2. If not set, check for a config.json file in the project root and use its TTS_PROVIDER value if present.
- * 3. If neither is set, default to 'elevenlabs'.
- *
- * Example config.json structure:
- * {
- *   "TTS_PROVIDER": "openai"
- * }
- */
-let TTS_PROVIDER = process.env.TTS_PROVIDER;
-let OPENAI_VOICE = process.env.OPENAI_VOICE;
-let ELEVENLABS_VOICE = process.env.ELEVENLABS_VOICE;
-
-try {
-    const configPath = path.join(__dirname, 'config.json');
-    if (fs.existsSync(configPath)) {
-        const configData = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
-        if (!TTS_PROVIDER && configData && typeof configData.TTS_PROVIDER === 'string' && configData.TTS_PROVIDER.trim()) {
-            TTS_PROVIDER = configData.TTS_PROVIDER.trim();
-        }
-        if (!OPENAI_VOICE && configData && typeof configData.OPENAI_VOICE === 'string' && configData.OPENAI_VOICE.trim()) {
-            OPENAI_VOICE = configData.OPENAI_VOICE.trim();
-        }
-        if (!ELEVENLABS_VOICE && configData && typeof configData.ELEVENLABS_VOICE === 'string' && configData.ELEVENLABS_VOICE.trim()) {
-            ELEVENLABS_VOICE = configData.ELEVENLABS_VOICE.trim();
-        }
-    }
-} catch (err) {
-    // Ignore config file errors, fallback to default
-}
-if (!TTS_PROVIDER) {
-    TTS_PROVIDER = 'elevenlabs';
-}
-// ------------------------------
-
-// --- CONFIGURATION ---
-// The API Key is now loaded securely from an environment variable
-const XI_API_KEY = process.env.XI_API_KEY;
-// --------------------
-
-// We wrap the entire script in an async function to use dynamic import() for node-fetch.
-async function main() {
-    // Dynamically import node-fetch v3, which is an ES-only module.
-    const { default: fetch } = await import('node-fetch');
-    const audioDir = path.join(__dirname, 'audio');
-    const dataDir = path.join(__dirname, 'data');
-
-    if (TTS_PROVIDER === 'elevenlabs' && !XI_API_KEY) {
-        console.error("FATAL: XI_API_KEY is not defined for ElevenLabs. Please add it to your .env file.");
-        process.exit(1);
-    }
-    if (!fs.existsSync(audioDir)) {
-        fs.mkdirSync(audioDir);
-    }
-
-    // --- NEW: Load all words from the JSON files ---
-    const allWords = new Set();
-    try {
-        const dataFiles = fs.readdirSync(dataDir).filter(file => file.endsWith('.json'));
-        for (const file of dataFiles) {
-            const filePath = path.join(dataDir, file);
-            const fileContent = fs.readFileSync(filePath, 'utf-8');
-            const levelData = JSON.parse(fileContent);
-            levelData.forEach(item => {
-                allWords.add(item.text);
-            });
-        }
-    } catch (error) {
-        console.error("Could not read data files from the 'data' directory.", error);
-        process.exit(1); // Exit if we can't read the data
-    }
-    // ------------------------------------------------
-
-    // --- CLEANUP: Remove audio files that are no longer needed ---
-    function cleanupUnusedAudioFiles() {
-        const audioFiles = fs.readdirSync(audioDir).filter(f => f.endsWith('.mp3'));
-        let removed = 0;
-        for (const file of audioFiles) {
-            const word = file.slice(0, -4); // Remove .mp3
-            if (!allWords.has(word)) {
-                const filePath = path.join(audioDir, file);
-                fs.unlinkSync(filePath);
-                console.log(`Removed unused audio file: ${file}`);
-                removed++;
-            }
-        }
-        if (removed === 0) {
-            console.log("No unused audio files to remove.");
-        } else {
-            console.log(`Removed ${removed} unused audio file(s).`);
-        }
-    }
-
-    async function generateAudioForWord(word) {
-        const fileName = `${word}.mp3`;
-        const filePath = path.join(audioDir, fileName);
-
-        if (fs.existsSync(filePath)) {
-            console.log(`Skipping "${word}", file already exists.`);
-            return;
-        }
-
-        console.log(`Generating audio for "${word}" using ${TTS_PROVIDER}...`);
-        try {
-            if (TTS_PROVIDER === 'openai') {
-                await openai.generateAudio(word, filePath, OPENAI_VOICE);
-            } else {
-                await elevenlabs.generateAudio(word, filePath, ELEVENLABS_VOICE);
-            }
-            console.log(`Successfully saved ${fileName}`);
-        } catch (err) {
-            console.error(`Error generating audio for "${word}":`, err.message || err);
-        }
-    }
-
-    // Helper: concurrency-limited pool
-    async function processWithConcurrencyLimit(items, worker, concurrency = 3) {
-        let index = 0;
-        let active = 0;
-        let results = [];
-        return new Promise((resolve, reject) => {
-            function next() {
-                if (index === items.length && active === 0) {
-                    resolve(Promise.all(results));
-                    return;
-                }
-                while (active < concurrency && index < items.length) {
-                    const i = index++;
-                    active++;
-                    const p = Promise.resolve(worker(items[i]))
-                        .catch(err => {
-                            // Log error but continue
-                            console.error(`Error processing item:`, err);
-                        })
-                        .finally(() => {
-                            active--;
-                            next();
-                        });
-                    results.push(p);
-                }
-            }
-            next();
-        });
-    }
-
-    async function processAllWords() {
-        console.log(`Found ${allWords.size} unique words to process.`);
-        // Gather missing words only
-        const missingWords = [];
-        for (const word of allWords) {
-            const fileName = `${word}.mp3`;
-            const filePath = path.join(audioDir, fileName);
-            if (!fs.existsSync(filePath)) {
-                missingWords.push(word);
-            }
-        }
-        console.log(`Need to generate ${missingWords.length} audio files (missing).`);
-
-        if (missingWords.length === 0) {
-            console.log("No missing audio files. All files are up to date.");
-            return;
-        }
-
-        // Concurrency limit (now configurable via env, default 2 for ElevenLabs)
-        const CONCURRENCY = parseInt(process.env.AUDIO_GEN_CONCURRENCY, 10) || 2;
-        console.log(`Using concurrency limit: ${CONCURRENCY}`);
-        await processWithConcurrencyLimit(
-            missingWords,
-            async (word) => {
-                await generateAudioForWord(word);
-                // Optional: small delay to avoid hammering API
-                await new Promise(resolve => setTimeout(resolve, 500));
-            },
-            CONCURRENCY
-        );
-        console.log("\nAll audio generation complete!");
-    }
-
-    cleanupUnusedAudioFiles();
-    await processAllWords();
-}
-
-// Execute the main function and catch any unhandled errors.
-main().catch(error => {
-    console.error("An unexpected error occurred:", error);
-    process.exit(1);
-});
\ No newline at end of file
diff --git a/openai.js b/openai.js
deleted file mode 100644
index 931560b..0000000
--- a/openai.js
+++ /dev/null
@@ -1,72 +0,0 @@
-const fs = require('fs').promises;
-const path = require('path');
-const https = require('https');
-
-/**
- * Generates speech audio from text using the OpenAI TTS API and writes it to the specified output path.
- * @param {string} word - The text to synthesize.
- * @param {string} outputPath - The file path to write the resulting audio.
- * @returns {Promise<void>}
- * @throws {Error} Throws if the API call fails or file writing fails.
- */
-async function generateAudio(word, outputPath, voice) {
-  const apiKey = process.env.OPENAI_API_KEY;
-  if (!apiKey) {
-    throw new Error('Missing OPENAI_API_KEY environment variable.');
-  }
-
-  const selectedVoice = voice || process.env.OPENAI_VOICE || 'alloy';
-
-  const apiUrl = 'https://api.openai.com/v1/audio/speech';
-  const requestBody = JSON.stringify({
-    model: 'tts-1-hd',
-    input: word,
-    voice: selectedVoice,
-    response_format: 'mp3'
-  });
-
-  const options = {
-    method: 'POST',
-    headers: {
-      'Authorization': `Bearer ${apiKey}`,
-      'Content-Type': 'application/json',
-      'Content-Length': Buffer.byteLength(requestBody)
-    }
-  };
-
-  await new Promise((resolve, reject) => {
-    const req = https.request(apiUrl, options, (res) => {
-      if (res.statusCode !== 200) {
-        let errorData = '';
-        res.on('data', chunk => errorData += chunk);
-        res.on('end', () => {
-          reject(new Error(`OpenAI API error: ${res.statusCode} - ${errorData}`));
-        });
-        return;
-      }
-
-      // Collect the audio data as a buffer
-      const data = [];
-      res.on('data', chunk => data.push(chunk));
-      res.on('end', async () => {
-        try {
-          const audioBuffer = Buffer.concat(data);
-          await fs.mkdir(path.dirname(outputPath), { recursive: true });
-          await fs.writeFile(outputPath, audioBuffer);
-          resolve();
-        } catch (err) {
-          reject(err);
-        }
-      });
-    });
-
-    req.on('error', (err) => {
-      reject(new Error(`Request error: ${err.message}`));
-    });
-
-    req.write(requestBody);
-    req.end();
-  });
-}
-
-module.exports = { generateAudio };
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 3e2bfb2..4eae9d6 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -7,6 +7,10 @@
     "": {
       "name": "type-learn",
       "version": "0.1.0",
+      "dependencies": {
+        "dotenv": "^17.2.1",
+        "node-fetch": "^3.3.2"
+      },
       "devDependencies": {
         "@tauri-apps/cli": "^2"
       }
@@ -227,6 +231,109 @@
       "engines": {
         "node": ">= 10"
       }
+    },
+    "node_modules/data-uri-to-buffer": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/data-uri-to-buffer/-/data-uri-to-buffer-4.0.1.tgz",
+      "integrity": "sha512-0R9ikRb668HB7QDxT1vkpuUBtqc53YyAwMwGeUFKRojY/NWKvdZ+9UYtRfGmhqNbRkTSVpMbmyhXipFFv2cb/A==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 12"
+      }
+    },
+    "node_modules/dotenv": {
+      "version": "17.2.1",
+      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.1.tgz",
+      "integrity": "sha512-kQhDYKZecqnM0fCnzI5eIv5L4cAe/iRI+HqMbO/hbRdTAeXDG+M9FjipUxNfbARuEg4iHIbhnhs78BCHNbSxEQ==",
+      "license": "BSD-2-Clause",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://dotenvx.com"
+      }
+    },
+    "node_modules/fetch-blob": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/fetch-blob/-/fetch-blob-3.2.0.tgz",
+      "integrity": "sha512-7yAQpD2UMJzLi1Dqv7qFYnPbaPx7ZfFK6PiIxQ4PfkGPyNyl2Ugx+a/umUonmKqjhM4DnfbMvdX6otXq83soQQ==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/jimmywarting"
+        },
+        {
+          "type": "paypal",
+          "url": "https://paypal.me/jimmywarting"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "node-domexception": "^1.0.0",
+        "web-streams-polyfill": "^3.0.3"
+      },
+      "engines": {
+        "node": "^12.20 || >= 14.13"
+      }
+    },
+    "node_modules/formdata-polyfill": {
+      "version": "4.0.10",
+      "resolved": "https://registry.npmjs.org/formdata-polyfill/-/formdata-polyfill-4.0.10.tgz",
+      "integrity": "sha512-buewHzMvYL29jdeQTVILecSaZKnt/RJWjoZCF5OW60Z67/GmSLBkOFM7qh1PI3zFNtJbaZL5eQu1vLfazOwj4g==",
+      "license": "MIT",
+      "dependencies": {
+        "fetch-blob": "^3.1.2"
+      },
+      "engines": {
+        "node": ">=12.20.0"
+      }
+    },
+    "node_modules/node-domexception": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/node-domexception/-/node-domexception-1.0.0.tgz",
+      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
+      "deprecated": "Use your platform's native DOMException instead",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/jimmywarting"
+        },
+        {
+          "type": "github",
+          "url": "https://paypal.me/jimmywarting"
+        }
+      ],
+      "license": "MIT",
+      "engines": {
+        "node": ">=10.5.0"
+      }
+    },
+    "node_modules/node-fetch": {
+      "version": "3.3.2",
+      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-3.3.2.tgz",
+      "integrity": "sha512-dRB78srN/l6gqWulah9SrxeYnxeddIG30+GOqK/9OlLVyLg3HPnr6SqOWTWOXKRwC2eGYCkZ59NNuSgvSrpgOA==",
+      "license": "MIT",
+      "dependencies": {
+        "data-uri-to-buffer": "^4.0.0",
+        "fetch-blob": "^3.1.4",
+        "formdata-polyfill": "^4.0.10"
+      },
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/node-fetch"
+      }
+    },
+    "node_modules/web-streams-polyfill": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/web-streams-polyfill/-/web-streams-polyfill-3.3.3.tgz",
+      "integrity": "sha512-d2JWLCivmZYTSIoge9MsgFCZrt571BikcWGYkjC1khllbTeDlGqZ2D8vD8E/lJa8WGWbb7Plm8/XJYV7IJHZZw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 8"
+      }
     }
   }
 }
diff --git a/package.json b/package.json
index 83efa48..d3cce2d 100644
--- a/package.json
+++ b/package.json
@@ -8,5 +8,9 @@
   },
   "devDependencies": {
     "@tauri-apps/cli": "^2"
+  },
+  "dependencies": {
+    "dotenv": "^17.2.1",
+    "node-fetch": "^3.3.2"
   }
 }
diff --git a/script.js b/script.js
deleted file mode 100644
index 59f47dc..0000000
--- a/script.js
+++ /dev/null
@@ -1,540 +0,0 @@
-// German keyboard layout (uppercase) - simplified
-        const keyboardLayout = [
-            ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'ß'],
-            ['Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O', 'P', 'Ü'],
-            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Ö', 'Ä'],
-            ['Y', 'X', 'C', 'V', 'B', 'N', 'M'],
-            [' '] // Space bar
-        ];
-
-        // Split points for keyboard halves (6|7, T|Z, G|H, B|N)
-        const splitPoints = [6, 5, 5, 5]; // Index where to split each row
-
-        // Home row keys for finger positioning
-        const homeRowKeys = ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Ö', 'Ä'];
-
-        // Finger colors for visual guidance
-        const fingerColors = {
-            'kleiner': '#FF6B6B',   // Pinky
-            'ring': '#4ECDC4',      // Ring finger
-            'mittel': '#FFD166',    // Middle finger
-            'zeige': '#1B98E0'      // Index finger
-        };
-
-        // Finger mapping for each key
-        const fingerMap = {
-            '1': 'kleiner', '2': 'ring', '3': 'mittel', '4': 'zeige',
-            '5': 'zeige', '6': 'zeige', '7': 'zeige', '8': 'mittel', '9': 'ring',
-            '0': 'kleiner', 'ß': 'kleiner',
-            'Q': 'kleiner', 'W': 'ring', 'E': 'mittel', 'R': 'zeige', 'T': 'zeige',
-            'Z': 'zeige', 'U': 'zeige', 'I': 'mittel', 'O': 'ring', 'P': 'kleiner',
-            'Ü': 'kleiner',
-            'A': 'kleiner', 'S': 'ring', 'D': 'mittel', 'F': 'zeige', 'G': 'zeige',
-            'H': 'zeige', 'J': 'zeige', 'K': 'mittel', 'L': 'ring', 'Ö': 'kleiner',
-            'Ä': 'kleiner',
-            'Y': 'kleiner', 'X': 'ring', 'C': 'mittel', 'V': 'zeige',
-            'B': 'zeige', 'N': 'zeige', 'M': 'zeige',
-            ' ': 'zeige'
-        };
-
-        let gameLevels = [];
-
-        // Current game state
-        let currentWord = "";
-        let currentIcons = [];
-        let currentIndex = 0;
-        let correctCount = 0;
-        let errorCount = 0;
-        let level = 0;
-        let progress = 0;
-        let currentKeyElement = null;
-        let speechSynthesis = window.speechSynthesis;
-        let usedWords = [];
-        let germanVoice = null;
-        const audioCache = new Map();
-
-        // DOM elements
-        const displayElement = document.getElementById('display');
-        const keyboardElement = document.getElementById('keyboard');
-        const progressElement = document.getElementById('progress');
-        const correctElement = document.getElementById('correct');
-        const errorsElement = document.getElementById('errors');
-        const levelDisplayElement = document.getElementById('levelDisplay');
-        const successMessage = document.getElementById('successMessage');
-        const wordIconsElement = document.getElementById('wordIcons');
-        const levelSelectElement = document.getElementById('levelSelect');
-        const prevLevelButton = document.getElementById('prevLevel');
-        const nextLevelButton = document.getElementById('nextLevel');
-
-        // Audio context for sound generation
-        let audioContext;
-
-        async function loadGameData() {
-            try {
-                const levelCount = levelSelectElement.options.length;
-                const fetchPromises = [];
-                for (let i = 0; i < levelCount; i++) {
-                    fetchPromises.push(fetch(`./data/level-${i}.json`).then(res => res.json()));
-                }
-                // Wait for all files to be fetched and parsed concurrently
-                gameLevels = await Promise.all(fetchPromises);
-                console.log("All game data loaded successfully.");
-            } catch (error) {
-                console.error("Fatal Error: Could not load game data.", error);
-                displayElement.textContent = "Fehler beim Laden der Spieldaten!";
-            }
-        }
-
-        // Helper function to create a single key element
-        function createKeyElement(key) {
-            const keyElement = document.createElement('div');
-            keyElement.className = 'key';
-            keyElement.textContent = key === ' ' ? 'Leertaste' : key;
-            keyElement.dataset.key = key;
-
-            if (key === ' ') {
-                keyElement.classList.add('space');
-            }
-
-            if (homeRowKeys.includes(key)) {
-                keyElement.classList.add('finger-home');
-            }
-
-            const finger = fingerMap[key] || 'kleiner';
-            const color = fingerColors[finger];
-            keyElement.style.borderColor = color;
-
-            keyElement.addEventListener('click', () => handleKeyPress(key));
-            return keyElement;
-        }
-
-        function goToNextLevel() {
-            level++;
-            if (level > 5) level = 5;
-            levelDisplayElement.textContent = level;
-            levelSelectElement.value = level;
-            progress = 0;
-            progressElement.style.width = '0%';
-            usedWords = [];
-        }
-
-        const rowOffsets = [0, -30, -5, 20];
-
-        function initKeyboard() {
-            keyboardElement.innerHTML = '';
-            const splitContainer = document.createElement('div');
-            splitContainer.className = 'keyboard-split';
-            const leftKeyboardHalf = document.createElement('div');
-            leftKeyboardHalf.className = 'keyboard-half';
-            const rightKeyboardHalf = document.createElement('div');
-            rightKeyboardHalf.className = 'keyboard-half';
-
-            keyboardLayout.forEach((row, rowIndex) => {
-                if (row[0] === ' ') return;
-                const offset = rowOffsets[rowIndex] || 0;
-                const splitPoint = splitPoints[rowIndex];
-
-                const leftKeys = row.slice(0, splitPoint);
-                const leftRowElement = document.createElement('div');
-                leftRowElement.className = 'keyboard-row';
-                leftRowElement.style.justifyContent = 'flex-end';
-                leftRowElement.style.position = 'relative';
-                leftRowElement.style.left = `${offset}px`;
-                leftKeys.forEach(key => leftRowElement.appendChild(createKeyElement(key)));
-                leftKeyboardHalf.appendChild(leftRowElement);
-
-                const rightKeys = row.slice(splitPoint);
-                const rightRowElement = document.createElement('div');
-                rightRowElement.className = 'keyboard-row';
-                rightRowElement.style.justifyContent = 'flex-start';
-                rightRowElement.style.position = 'relative';
-                rightRowElement.style.left = `${offset}px`;
-                rightKeys.forEach(key => rightRowElement.appendChild(createKeyElement(key)));
-                rightKeyboardHalf.appendChild(rightRowElement);
-            });
-
-            splitContainer.appendChild(leftKeyboardHalf);
-            splitContainer.appendChild(rightKeyboardHalf);
-            keyboardElement.appendChild(splitContainer);
-
-            const spaceRowLayout = keyboardLayout[keyboardLayout.length - 1];
-            const spaceRowElement = document.createElement('div');
-            spaceRowElement.className = 'keyboard-row';
-            spaceRowElement.style.justifyContent = 'center';
-            const spaceKeyElement = createKeyElement(spaceRowLayout[0]);
-            spaceRowElement.appendChild(spaceKeyElement);
-            keyboardElement.appendChild(spaceRowElement);
-        }
-
-        function getWordsForLevel() {
-            return gameLevels[level] || [];
-        }
-
-        function generateNewWord() {
-            const words = getWordsForLevel();
-            if (!words || words.length === 0) return; // Safeguard
-            if (usedWords.length >= words.length) usedWords = [];
-            
-            const availableWords = words.filter((_, index) => !usedWords.includes(index));
-            const randomIndex = Math.floor(Math.random() * availableWords.length);
-            const selectedWord = availableWords[randomIndex];
-            const wordIndex = words.indexOf(selectedWord);
-            usedWords.push(wordIndex);
-
-            // Use the consistent 'text' property from our JSON files
-            currentWord = selectedWord.text; 
-            currentIcons = selectedWord.icons;
-
-            currentIndex = 0;
-            displayElement.textContent = currentWord.split('').map((char, i) => i === currentIndex ? `[${char}]` : char).join('');
-            wordIconsElement.innerHTML = '';
-            (currentIcons || []).forEach((icon, i) => { // Added safeguard for missing icons
-                const iconElement = document.createElement('div');
-                iconElement.className = 'icon';
-                iconElement.textContent = icon;
-                iconElement.style.animationDelay = `${i * 0.2}s`;
-                wordIconsElement.appendChild(iconElement);
-            });
-
-            speakWord(currentWord);
-            highlightNextKey();
-        }
-
-        async function speakWord(word) {
-            // Priority 1: Try to play the pre-generated local audio file.
-            const fileName = `${encodeURIComponent(word)}.mp3`;
-            const localAudioPath = `./audio/${fileName}`;
-
-            try {
-                const response = await fetch(localAudioPath);
-                if (response.ok) {
-                    const audioBlob = await response.blob();
-                    const audioUrl = URL.createObjectURL(audioBlob);
-                    const audio = new Audio(audioUrl);
-                    audio.addEventListener('ended', () => URL.revokeObjectURL(audioUrl));
-                    audio.play();
-                    console.log(`Played "${word}" from local file: ${localAudioPath}`);
-                    return;
-                } else {
-                    console.warn(`Local file for "${word}" not found at ${localAudioPath} (${response.status}). Falling back to browser TTS.`);
-                }
-            } catch (error) {
-                console.error(`Error loading local file for "${word}" from ${localAudioPath}:`, error);
-            }
-
-            // Priority 2: If local file fails, fall back to the browser's default voice.
-            speechSynthesis.cancel();
-            const utterance = new SpeechSynthesisUtterance(word);
-            utterance.lang = 'de-DE';
-            utterance.rate = 0.8;
-            utterance.pitch = 1.1;
-            utterance.volume = 1.0;
-            if (germanVoice) {
-                utterance.voice = germanVoice;
-            }
-            speechSynthesis.speak(utterance);
-        }
-
-        function highlightNextKey() {
-            if (currentKeyElement) {
-                currentKeyElement.classList.remove('highlight');
-                currentKeyElement.style.background = 'rgba(255, 255, 255, 0.25)';
-            }
-            const nextChar = currentWord[currentIndex];
-            if (!nextChar) return;
-            currentKeyElement = document.querySelector(`.key[data-key="${nextChar}"]`);
-            if (currentKeyElement) {
-                currentKeyElement.classList.add('highlight');
-                const finger = fingerMap[nextChar] || 'kleiner';
-                currentKeyElement.style.background = fingerColors[finger];
-            }
-        }
-
-        function playSound(frequency, duration, type = 'sine') {
-            if (!audioContext) return;
-            const now = audioContext.currentTime;
-            const peakVolume = 0.25;
-            const attackTime = 0.05;
-            const decayTime = (duration / 1000) - attackTime;
-            const oscillator = audioContext.createOscillator();
-            const gainNode = audioContext.createGain();
-            oscillator.connect(gainNode);
-            gainNode.connect(audioContext.destination);
-            oscillator.type = type;
-            oscillator.frequency.value = frequency;
-            gainNode.gain.setValueAtTime(0, now);
-            gainNode.gain.linearRampToValueAtTime(peakVolume, now + attackTime);
-            gainNode.gain.linearRampToValueAtTime(0, now + attackTime + decayTime);
-            oscillator.start(now);
-            oscillator.stop(now + duration / 1000);
-        }
-
-        function playLevelUpFanfare() {
-            const C5 = 523.25, G5 = 783.99, C6 = 1046.50, E6 = 1318.51, G6 = 1567.98;
-            setTimeout(() => playSound(C5, 100, 'triangle'), 0);
-            setTimeout(() => playSound(G5, 100, 'triangle'), 120);
-            setTimeout(() => playSound(C6, 250, 'triangle'), 240);
-            setTimeout(() => { playSound(E6, 400, 'triangle'); playSound(G6, 400, 'triangle'); }, 550);
-        }
-
-        function handleKeyPress(key) {
-            if (!gameStarted) return; // Ignore key presses before the game starts
-
-            // Ignore modifier keys and function keys
-            const modifierKeys = [
-                'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'ContextMenu', 'ScrollLock', 'Pause', 'Insert', 'Home', 'End', 'PageUp', 'PageDown',
-                // Function keys F1-F24
-                ...Array.from({length: 24}, (_, i) => `F${i+1}`)
-            ];
-            if (modifierKeys.includes(key)) return;
-
-            // Highlight the pressed key
-            const keyElement = document.querySelector(`.key[data-key="${key}"]`);
-            if (keyElement) {
-                keyElement.classList.add('active');
-                setTimeout(() => keyElement.classList.remove('active'), 150);
-            }
-
-            // Check if the key matches the current character
-            if (key === currentWord[currentIndex]) {
-                // --- CORRECT KEY PRESS ---
-                correctCount++;
-                correctElement.textContent = correctCount;
-                createParticles(keyElement);
-
-                currentIndex++;
-                updateDisplayAndCheckState();
-            } else {
-                // --- INCORRECT KEY PRESS ---
-                errorCount++;
-                errorsElement.textContent = errorCount;
-                playSound(164.81, 250, 'sine');
-
-                displayElement.classList.add('error-flash');
-                setTimeout(() => {
-                    displayElement.classList.remove('error-flash');
-                }, 300);
-
-                if (keyElement) {
-                    keyElement.classList.add('shake');
-                    setTimeout(() => keyElement.classList.remove('shake'), 500);
-                }
-            }
-        }
-
-        function updateDisplayAndCheckState() {
-            // Word finished?
-            if (currentIndex >= currentWord.length) {
-                progress += 10;
-                if (progress >= 100) {
-                    // Level finished!
-                    progress = 100;
-                    levelUp(); // Plays fanfare and shows message
-                    setTimeout(generateNewWord, 2000); // Longer wait for fanfare
-                } else {
-                    // Just the word is finished
-                    playWordCompleteSound();
-                    createFireworks();
-                    setTimeout(generateNewWord, 1000);
-                }
-                progressElement.style.width = `${progress}%`;
-            } else {
-                // Just a correct key press
-                playSound(783.99, 150, 'triangle');
-                displayElement.textContent = currentWord.split('').map((char, i) => i === currentIndex ? `[${char}]` : char).join('');
-                highlightNextKey();
-            }
-        }
-
-        function playWordCompleteSound() {
-            playSound(523.25, 100, 'sine');
-            setTimeout(() => playSound(659.25, 100, 'sine'), 150);
-            setTimeout(() => playSound(783.99, 100, 'sine'), 300);
-            setTimeout(() => playSound(1046.50, 300, 'sine'), 450);
-        }
-
-        function levelUp() {
-            playLevelUpFanfare();
-            level++;
-            if (level > 5) level = 5;
-            levelDisplayElement.textContent = level;
-            levelSelectElement.value = level;
-            progress = 0;
-            progressElement.style.width = '0%';
-            usedWords = [];
-            successMessage.style.display = 'block';
-            setTimeout(() => { successMessage.style.display = 'none'; }, 2000);
-        }
-
-        function levelDown() {
-            level--;
-            if (level < 0) level = 0;
-            levelDisplayElement.textContent = level;
-            levelSelectElement.value = level;
-            progress = 0;
-            progressElement.style.width = '0%';
-            usedWords = [];
-        }
-
-        function setLevel(newLevel) {
-            level = newLevel;
-            levelDisplayElement.textContent = level;
-            levelSelectElement.value = level;
-            progress = 0;
-            progressElement.style.width = '0%';
-            usedWords = [];
-            generateNewWord();
-        }
-
-        function createParticles(element) {
-            const rect = element.getBoundingClientRect();
-            const centerX = rect.left + rect.width / 2;
-            const centerY = rect.top + rect.height / 2;
-            for (let i = 0; i < 20; i++) {
-                const particle = document.createElement('div');
-                particle.className = 'particle';
-                particle.style.left = `${centerX}px`;
-                particle.style.top = `${centerY}px`;
-                particle.style.backgroundColor = getRandomColor();
-                document.body.appendChild(particle);
-                const angle = Math.random() * Math.PI * 2;
-                const distance = 50 + Math.random() * 100;
-                const duration = 0.5 + Math.random() * 0.5;
-                particle.animate([
-                    { transform: 'translate(0, 0)', opacity: 1 },
-                    { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`, opacity: 0 }
-                ], { duration: duration * 1000, easing: 'ease-out' });
-                setTimeout(() => { particle.remove(); }, duration * 1000);
-            }
-        }
-
-        function createFireworks() {
-            for (let i = 0; i < 5; i++) {
-                setTimeout(() => {
-                    const firework = document.createElement('div');
-                    firework.className = 'firework';
-                    firework.style.left = `${Math.random() * window.innerWidth}px`;
-                    firework.style.top = `${Math.random() * window.innerHeight / 2}px`;
-                    firework.style.backgroundColor = getRandomColor();
-                    document.body.appendChild(firework);
-                    const angle = Math.random() * Math.PI * 2;
-                    const distance = 100 + Math.random() * 200;
-                    const duration = 1 + Math.random() * 1;
-                    firework.animate([
-                        { transform: 'translate(0, 0)', opacity: 1, width: '5px', height: '5px' },
-                        { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`, opacity: 0, width: '2px', height: '2px' }
-                    ], { duration: duration * 1000, easing: 'ease-out' });
-                    setTimeout(() => { firework.remove(); }, duration * 1000);
-                }, i * 300);
-            }
-        }
-
-        function getRandomColor() {
-            const colors = ['#FF6B6B', '#4ECDC4', '#FFD166', '#1B98E0', '#C44569', '#F8B500', '#6C5CE7'];
-            return colors[Math.floor(Math.random() * colors.length)];
-        }
-
-        document.addEventListener('keydown', (event) => {
-            // Only handle game-related key presses if the game has actually started
-            if (gameStarted) {
-                // Ignore modifier keys
-                if (
-                    event.ctrlKey || event.altKey || event.metaKey ||
-                    ['Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'ContextMenu', 'ScrollLock', 'Pause', 'Insert', 'Home', 'End', 'PageUp', 'PageDown',
-                    // Function keys F1-F24
-                    ...Array.from({length: 24}, (_, i) => `F${i+1}`)
-                    ].includes(event.key)
-                ) {
-                    return;
-                }
-                if (event.key === ' ') event.preventDefault();
-                const key = event.key === 'ß' ? 'ß' : event.key.toUpperCase();
-
-                // Allow 'Enter' to generate a new word only during the game
-                if (event.key === 'Enter') {
-                    generateNewWord();
-                } else {
-                    handleKeyPress(key);
-                }
-            }
-        });
-
-        let gameStarted = false;
-
-        function initializeSpeech() {
-            return new Promise((resolve) => {
-                let tried = false;
-                function findVoice() {
-                    if (tried) return;
-                    tried = true;
-
-                    const voices = speechSynthesis.getVoices();
-                    germanVoice = voices.find(v => v.lang === 'de-DE' && v.name.includes("Google"))
-                        || voices.find(v => v.lang === 'de-DE')
-                        || voices.find(v => v.lang.startsWith("de"));
-
-                    if (germanVoice) {
-                        console.log("✅ Stimme gefunden:", germanVoice.name);
-                    } else {
-                        console.warn("⚠️ Keine deutsche Stimme gefunden.");
-                    }
-
-                    speechSynthesis.onvoiceschanged = null;
-                    resolve();
-                }
-
-                const voices = speechSynthesis.getVoices();
-                if (voices.length > 0) {
-                    findVoice();
-                } else {
-                    speechSynthesis.onvoiceschanged = findVoice;
-                    setTimeout(findVoice, 500); // fallback if event doesn't fire
-                }
-            });
-        }
-
-        async function startGame(event) {
-            if (event && event.target) {
-                const targetTag = event.target.tagName.toUpperCase();
-                if (['INPUT', 'SELECT', 'BUTTON'].includes(targetTag)) {
-                    if (event.type === 'click') { displayElement.addEventListener('click', (e) => startGame(e), { once: true }); } 
-                    else if (event.type === 'keydown') { document.addEventListener('keydown', (e) => startGame(e), { once: true }); }
-                    return;
-                }
-            }
-            if (gameStarted) return;
-            
-            // Ensure data is loaded before starting
-            if (gameLevels.length === 0) {
-                console.log("Data not loaded yet, awaiting load...");
-                await loadGameData();
-            }
-
-            gameStarted = true;
-
-            if (!audioContext) {
-                audioContext = new (window.AudioContext || window.webkitAudioContext)();
-            }
-            displayElement.style.cursor = "default";
-            generateNewWord();
-        }
-
-        async function initGame() {
-            displayElement.textContent = "Lade Spieldaten...";
-            await loadGameData(); // Load data as soon as the page opens
-
-            initKeyboard();
-            await startGame();
-
-            correctElement.textContent = correctCount;
-            errorsElement.textContent = errorCount;
-            levelDisplayElement.textContent = level;
-            levelSelectElement.value = level;
-            
-            // All button event listeners remain the same
-            prevLevelButton.addEventListener('click', () => { if (gameStarted) { levelDown(); generateNewWord(); } });
-            nextLevelButton.addEventListener('click', () => { if (gameStarted) { goToNextLevel(); generateNewWord(); } });
-            levelSelectElement.addEventListener('change', (e) => { if (gameStarted) { setLevel(parseInt(e.target.value)); } });
-        }
-
-        window.onload = initGame;
\ No newline at end of file
diff --git a/src/audio/ALLES GUTE.mp3 b/src/audio/ALLES GUTE.mp3
deleted file mode 100644
index 11a4bdc..0000000
Binary files a/src/audio/ALLES GUTE.mp3 and /dev/null differ
diff --git "a/src/audio/DER GARTEN IST SEHR SCH\303\226N.mp3" "b/src/audio/DER GARTEN IST SEHR SCH\303\226N.mp3"
deleted file mode 100644
index ad731d1..0000000
Binary files "a/src/audio/DER GARTEN IST SEHR SCH\303\226N.mp3" and /dev/null differ
diff --git a/src/audio/DER VOGEL SINGT IM BAUM.mp3 b/src/audio/DER VOGEL SINGT IM BAUM.mp3
deleted file mode 100644
index 1bebd76..0000000
Binary files a/src/audio/DER VOGEL SINGT IM BAUM.mp3 and /dev/null differ
diff --git a/src/audio/GUTE NACHT.mp3 b/src/audio/GUTE NACHT.mp3
deleted file mode 100644
index 92c3b0c..0000000
Binary files a/src/audio/GUTE NACHT.mp3 and /dev/null differ
diff --git a/src/audio/GUTEN MORGEN.mp3 b/src/audio/GUTEN MORGEN.mp3
deleted file mode 100644
index e5b70bb..0000000
Binary files a/src/audio/GUTEN MORGEN.mp3 and /dev/null differ
diff --git a/src/audio/HEUTE GEHE ICH IN DIE SCHULE.mp3 b/src/audio/HEUTE GEHE ICH IN DIE SCHULE.mp3
deleted file mode 100644
index 49178e6..0000000
Binary files a/src/audio/HEUTE GEHE ICH IN DIE SCHULE.mp3 and /dev/null differ
diff --git a/src/audio/ICH BIN DREI JAHRE ALT.mp3 b/src/audio/ICH BIN DREI JAHRE ALT.mp3
deleted file mode 100644
index 9af5334..0000000
Binary files a/src/audio/ICH BIN DREI JAHRE ALT.mp3 and /dev/null differ
diff --git a/src/audio/ICH BIN DREI.mp3 b/src/audio/ICH BIN DREI.mp3
deleted file mode 100644
index 0dbefb7..0000000
Binary files a/src/audio/ICH BIN DREI.mp3 and /dev/null differ
diff --git a/src/audio/ICH BIN FROH.mp3 b/src/audio/ICH BIN FROH.mp3
deleted file mode 100644
index 8ebde48..0000000
Binary files a/src/audio/ICH BIN FROH.mp3 and /dev/null differ
diff --git "a/src/audio/ICH BIN GRO\303\237.mp3" "b/src/audio/ICH BIN GRO\303\237.mp3"
deleted file mode 100644
index 58137bb..0000000
Binary files "a/src/audio/ICH BIN GRO\303\237.mp3" and /dev/null differ
diff --git a/src/audio/ICH BIN KLEIN.mp3 b/src/audio/ICH BIN KLEIN.mp3
deleted file mode 100644
index 6e31c64..0000000
Binary files a/src/audio/ICH BIN KLEIN.mp3 and /dev/null differ
diff --git "a/src/audio/ICH BIN M\303\234DE.mp3" "b/src/audio/ICH BIN M\303\234DE.mp3"
deleted file mode 100644
index 7f1af74..0000000
Binary files "a/src/audio/ICH BIN M\303\234DE.mp3" and /dev/null differ
diff --git a/src/audio/ICH BIN TRAURIG.mp3 b/src/audio/ICH BIN TRAURIG.mp3
deleted file mode 100644
index 9603b7c..0000000
Binary files a/src/audio/ICH BIN TRAURIG.mp3 and /dev/null differ
diff --git a/src/audio/ICH ESSE GERN EIS.mp3 b/src/audio/ICH ESSE GERN EIS.mp3
deleted file mode 100644
index b9f3846..0000000
Binary files a/src/audio/ICH ESSE GERN EIS.mp3 and /dev/null differ
diff --git a/src/audio/ICH HABE DURST.mp3 b/src/audio/ICH HABE DURST.mp3
deleted file mode 100644
index 51b24c3..0000000
Binary files a/src/audio/ICH HABE DURST.mp3 and /dev/null differ
diff --git a/src/audio/ICH HABE EINEN HUND.mp3 b/src/audio/ICH HABE EINEN HUND.mp3
deleted file mode 100644
index 41e86d8..0000000
Binary files a/src/audio/ICH HABE EINEN HUND.mp3 and /dev/null differ
diff --git a/src/audio/ICH HABE HUNGER.mp3 b/src/audio/ICH HABE HUNGER.mp3
deleted file mode 100644
index 468806a..0000000
Binary files a/src/audio/ICH HABE HUNGER.mp3 and /dev/null differ
diff --git a/src/audio/ICH HABE VIELE FREUNDE.mp3 b/src/audio/ICH HABE VIELE FREUNDE.mp3
deleted file mode 100644
index 0d2a3bc..0000000
Binary files a/src/audio/ICH HABE VIELE FREUNDE.mp3 and /dev/null differ
diff --git a/src/audio/ICH HOFFE ES REGENET NICHT.mp3 b/src/audio/ICH HOFFE ES REGENET NICHT.mp3
deleted file mode 100644
index 54016cc..0000000
Binary files a/src/audio/ICH HOFFE ES REGENET NICHT.mp3 and /dev/null differ
diff --git a/src/audio/ICH LERNE JEDEN TAG ETWAS NEUES.mp3 b/src/audio/ICH LERNE JEDEN TAG ETWAS NEUES.mp3
deleted file mode 100644
index 182822a..0000000
Binary files a/src/audio/ICH LERNE JEDEN TAG ETWAS NEUES.mp3 and /dev/null differ
diff --git a/src/audio/ICH LERNE LESEN UND SCHREIBEN.mp3 b/src/audio/ICH LERNE LESEN UND SCHREIBEN.mp3
deleted file mode 100644
index 6ea0698..0000000
Binary files a/src/audio/ICH LERNE LESEN UND SCHREIBEN.mp3 and /dev/null differ
diff --git "a/src/audio/ICH LESE GERN ABENTEUERB\303\234CHER.mp3" "b/src/audio/ICH LESE GERN ABENTEUERB\303\234CHER.mp3"
deleted file mode 100644
index d7c5cdb..0000000
Binary files "a/src/audio/ICH LESE GERN ABENTEUERB\303\234CHER.mp3" and /dev/null differ
diff --git a/src/audio/ICH LIEBE DICH.mp3 b/src/audio/ICH LIEBE DICH.mp3
deleted file mode 100644
index a582d05..0000000
Binary files a/src/audio/ICH LIEBE DICH.mp3 and /dev/null differ
diff --git "a/src/audio/MEIN FREUND HEI\303\237T MAX.mp3" "b/src/audio/MEIN FREUND HEI\303\237T MAX.mp3"
deleted file mode 100644
index 8cba949..0000000
Binary files "a/src/audio/MEIN FREUND HEI\303\237T MAX.mp3" and /dev/null differ
diff --git a/src/audio/MEIN LIEBLINGSSPIEL IST FANGEN.mp3 b/src/audio/MEIN LIEBLINGSSPIEL IST FANGEN.mp3
deleted file mode 100644
index b46b061..0000000
Binary files a/src/audio/MEIN LIEBLINGSSPIEL IST FANGEN.mp3 and /dev/null differ
diff --git a/src/audio/MEIN NAME IST.mp3 b/src/audio/MEIN NAME IST.mp3
deleted file mode 100644
index 842b593..0000000
Binary files a/src/audio/MEIN NAME IST.mp3 and /dev/null differ
diff --git a/src/audio/MEINE FAMILIE IST SEHR LIEB.mp3 b/src/audio/MEINE FAMILIE IST SEHR LIEB.mp3
deleted file mode 100644
index c61530d..0000000
Binary files a/src/audio/MEINE FAMILIE IST SEHR LIEB.mp3 and /dev/null differ
diff --git a/src/audio/MEINE LIEBLINGSFARBE IST BLAU.mp3 b/src/audio/MEINE LIEBLINGSFARBE IST BLAU.mp3
deleted file mode 100644
index a640f99..0000000
Binary files a/src/audio/MEINE LIEBLINGSFARBE IST BLAU.mp3 and /dev/null differ
diff --git a/src/audio/MEINE MUTTER BACKT KUCHEN.mp3 b/src/audio/MEINE MUTTER BACKT KUCHEN.mp3
deleted file mode 100644
index eb80718..0000000
Binary files a/src/audio/MEINE MUTTER BACKT KUCHEN.mp3 and /dev/null differ
diff --git "a/src/audio/SCH\303\226NEN TAG.mp3" "b/src/audio/SCH\303\226NEN TAG.mp3"
deleted file mode 100644
index 56d7048..0000000
Binary files "a/src/audio/SCH\303\226NEN TAG.mp3" and /dev/null differ
diff --git "a/src/audio/VIEL GL\303\234CK.mp3" "b/src/audio/VIEL GL\303\234CK.mp3"
deleted file mode 100644
index a890c44..0000000
Binary files "a/src/audio/VIEL GL\303\234CK.mp3" and /dev/null differ
diff --git a/src/audio/WIR BACKEN ZUSAMMEN KUCHEN.mp3 b/src/audio/WIR BACKEN ZUSAMMEN KUCHEN.mp3
deleted file mode 100644
index be12ebf..0000000
Binary files a/src/audio/WIR BACKEN ZUSAMMEN KUCHEN.mp3 and /dev/null differ
diff --git a/src/audio/WIR GEHEN IN DEN PARK.mp3 b/src/audio/WIR GEHEN IN DEN PARK.mp3
deleted file mode 100644
index cd4104b..0000000
Binary files a/src/audio/WIR GEHEN IN DEN PARK.mp3 and /dev/null differ
diff --git a/src/audio/WIR MACHEN EINEN AUSFLUG.mp3 b/src/audio/WIR MACHEN EINEN AUSFLUG.mp3
deleted file mode 100644
index 2e14dd0..0000000
Binary files a/src/audio/WIR MACHEN EINEN AUSFLUG.mp3 and /dev/null differ
diff --git a/src/audio/WIR SPIELEN FUSSBALL.mp3 b/src/audio/WIR SPIELEN FUSSBALL.mp3
deleted file mode 100644
index 19929d0..0000000
Binary files a/src/audio/WIR SPIELEN FUSSBALL.mp3 and /dev/null differ
diff --git a/src/data/level-5.json b/src/data/level-5.json
index 99b4b84..6d7bc11 100644
--- a/src/data/level-5.json
+++ b/src/data/level-5.json
@@ -8,5 +8,5 @@
     {"text": "ICH LERNE JEDEN TAG ETWAS NEUES", "icons": ["📚", "🆕"]},
     {"text": "WIR BACKEN ZUSAMMEN KUCHEN", "icons": ["👩‍🍳", "🍰"]},
     {"text": "DER GARTEN IST SEHR SCHÖN", "icons": ["🌳", "🌺"]},
-    {"text": "ICH HOFFE ES REGENET NICHT", "icons": ["🌧️", "☔"]}
+    {"text": "ICH HOFFE ES REGNET NICHT", "icons": ["🌧️", "☔"]}
 ]
\ No newline at end of file
diff --git a/src/main.js b/src/main.js
index 0045da4..d847f69 100644
--- a/src/main.js
+++ b/src/main.js
@@ -1,23 +1,3 @@
-const { invoke } = window.__TAURI__.core;
-
-let greetInputEl;
-let greetMsgEl;
-
-async function greet() {
-  // Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
-  greetMsgEl.textContent = await invoke("greet", { name: greetInputEl.value });
-}
-
-window.addEventListener("DOMContentLoaded", () => {
-  greetInputEl = document.querySelector("#greet-input");
-  greetMsgEl = document.querySelector("#greet-msg");
-  document.querySelector("#greet-form").addEventListener("submit", (e) => {
-    e.preventDefault();
-    greet();
-  });
-});
-
-
 // German keyboard layout (uppercase) - simplified
 const keyboardLayout = [
     ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'ß'],
@@ -138,7 +118,7 @@ function goToNextLevel() {
     usedWords = [];
 }
 
-const rowOffsets = [0, -30, -05, 20];
+const rowOffsets = [0, -30, -5, 20];
 
 function initKeyboard() {
     keyboardElement.innerHTML = '';
@@ -222,19 +202,37 @@ function generateNewWord() {
 
 async function speakWord(word) {
     // Priority 1: Try to play the pre-generated local audio file.
-    const fileName = `${encodeURIComponent(word)}.mp3`;
+    // Normalize filename: underscores for spaces, ASCII for special chars.
+    function normalizeFilename(str) {
+        return str
+            .replaceAll(" ", "_")
+            .replaceAll("Ä", "AE")
+            .replaceAll("Ö", "OE")
+            .replaceAll("Ü", "UE")
+            .replaceAll("ä", "ae")
+            .replaceAll("ö", "oe")
+            .replaceAll("ü", "ue")
+            .replaceAll("ß", "SS")
+            .replace(/[^A-Za-z0-9_]/g, ""); // Remove any other non-ASCII chars
+    }
+    const fileName = `${normalizeFilename(word)}.mp3`;
     const localAudioPath = `./audio/${fileName}`;
 
     try {
         const response = await fetch(localAudioPath);
         if (response.ok) {
             const audioBlob = await response.blob();
-            const audioUrl = URL.createObjectURL(audioBlob);
-            const audio = new Audio(audioUrl);
-            audio.addEventListener('ended', () => URL.revokeObjectURL(audioUrl));
-            audio.play();
-            console.log(`Played "${word}" from local file: ${localAudioPath}`);
-            return;
+            console.log(`Blob type for "${word}":`, audioBlob.type);
+            if (!audioBlob.type.startsWith('audio/')) {
+                console.error(`Blob for "${word}" is not a valid audio type:`, audioBlob.type);
+            } else {
+                const audioUrl = URL.createObjectURL(audioBlob);
+                const audio = new Audio(audioUrl);
+                audio.addEventListener('ended', () => URL.revokeObjectURL(audioUrl));
+                audio.play();
+                console.log(`Played "${word}" from local file: ${localAudioPath}`);
+                return;
+            }
         } else {
             console.warn(`Local file for "${word}" not found at ${localAudioPath} (${response.status}). Falling back to browser TTS.`);
         }
@@ -298,7 +296,15 @@ function playLevelUpFanfare() {
 }
 
 function handleKeyPress(key) {
-    if (!gameStarted) return; // Add this line to ignore key presses before the game starts
+    if (!gameStarted) return; // Ignore key presses before the game starts
+
+    // Ignore modifier keys and function keys
+    const modifierKeys = [
+        'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'ContextMenu', 'ScrollLock', 'Pause', 'Insert', 'Home', 'End', 'PageUp', 'PageDown',
+        // Function keys F1-F24
+        ...Array.from({length: 24}, (_, i) => `F${i+1}`)
+    ];
+    if (modifierKeys.includes(key)) return;
 
     // Highlight the pressed key
     const keyElement = document.querySelector(`.key[data-key="${key}"]`);
@@ -449,6 +455,16 @@ function getRandomColor() {
 document.addEventListener('keydown', (event) => {
     // Only handle game-related key presses if the game has actually started
     if (gameStarted) {
+        // Ignore modifier keys
+        if (
+            event.ctrlKey || event.altKey || event.metaKey ||
+            ['Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'ContextMenu', 'ScrollLock', 'Pause', 'Insert', 'Home', 'End', 'PageUp', 'PageDown',
+            // Function keys F1-F24
+            ...Array.from({length: 24}, (_, i) => `F${i+1}`)
+            ].includes(event.key)
+        ) {
+            return;
+        }
         if (event.key === ' ') event.preventDefault();
         const key = event.key === 'ß' ? 'ß' : event.key.toUpperCase();
 
@@ -526,11 +542,7 @@ async function initGame() {
     await loadGameData(); // Load data as soon as the page opens
 
     initKeyboard();
-    displayElement.textContent = "Klicke, um zu starten!";
-    displayElement.style.cursor = "pointer";
-
-    displayElement.addEventListener('click', (e) => startGame(e), { once: true });
-    document.addEventListener('keydown', (e) => startGame(e), { once: true });
+    await startGame();
 
     correctElement.textContent = correctCount;
     errorsElement.textContent = errorCount;
diff --git a/src/styles.css b/src/styles.css
index b01dd18..6eefee8 100644
--- a/src/styles.css
+++ b/src/styles.css
@@ -170,6 +170,7 @@
             font-size: 3rem;
             animation: float 3s ease-in-out infinite;
             filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
+            font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "EmojiOne Color", sans-serif;
         }
 
         @keyframes float {
